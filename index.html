<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>생존 게임</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #1a2a3a; }
    canvas { display: block; }
    #upgrade-modal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        border: 3px solid #ffd700;
        text-align: center;
        display: none;
        font-family: 'Malgun Gothic', sans-serif;
        z-index: 100;
    }
    #upgrade-modal h2 { margin-top: 0; color: #ffd700; }
    .upgrade-option {
        background-color: #5a6a7a;
        border: 2px solid #c0c0c0;
        color: white;
        padding: 15px 25px;
        margin: 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1.1em;
        transition: background-color 0.3s, transform 0.2s;
    }
    .upgrade-option:hover { background-color: #7a8a9a; transform: scale(1.05); }
    #joystick-container {
        position: absolute;
        bottom: 50px;
        left: 50px;
        width: 120px;
        height: 120px;
        display: none; /* Hidden on desktop */
    }
    #joystick-base {
        position: absolute;
        width: 120px;
        height: 120px;
        background: rgba(128, 128, 128, 0.5);
        border-radius: 50%;
    }
    #joystick-stick {
        position: absolute;
        width: 60px;
        height: 60px;
        background: rgba(200, 200, 200, 0.7);
        border-radius: 50%;
        top: 30px;
        left: 30px;
    }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="upgrade-modal">
    <h2>레벨 업!</h2>
    <p>능력을 선택하세요:</p>
    <div id="upgrade-options"></div>
</div>
<div id="joystick-container">
    <div id="joystick-base"></div>
    <div id="joystick-stick"></div>
</div>

<script>
// --- 기존 게임 코드 (수정 없음) ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const upgradeModal = document.getElementById('upgrade-modal');
const upgradeOptionsContainer = document.getElementById('upgrade-options');

let player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    size: 20,
    speed: 3,
    health: 100,
    maxHealth: 100,
    xp: 0,
    level: 1,
    xpToNextLevel: 100,
    attackSpeed: 1000, // ms
    projectileSpeed: 5,
    projectileDamage: 10,
    numProjectiles: 1,
    barrier: { active: false, size: 60, damage: 5, rotation: 0 },
};

let keys = {};
let projectiles = [];
let enemies = [];
let xpGems = [];
let allies = [];
let gamePaused = false;
let barrierInterval;

function gameOver() {
    alert('게임 오버!');
    document.location.reload();
}

// Game Loop
function gameLoop() {
    if (gamePaused) return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Update
function update() {
    handlePlayerMovement();
    updateProjectiles();
    updateAllies();
    updateEnemies();
    handleCollisions();
    if (player.barrier.active) {
        player.barrier.rotation += 0.02;
    }
}

// Draw
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPlayer();
    if (player.barrier.active) drawBarrier();
    projectiles.forEach(drawProjectile);
    allies.forEach(drawAlly);
    enemies.forEach(drawEnemy);
    xpGems.forEach(drawXpGem);
    drawUI();
}

// Player & Allies
function drawPlayer() {
    ctx.fillStyle = '#3498db';
    ctx.fillRect(player.x - player.size / 2, player.y - player.size / 2, player.size, player.size);
}

function drawAlly(ally) {
    ctx.fillStyle = '#9b59b6';
    ctx.beginPath();
    ctx.arc(ally.x, ally.y, ally.size, 0, Math.PI * 2);
    ctx.fill();
}

function updateAllies() {
    allies.forEach(ally => {
        // Simple follow logic
        ally.x += (player.x - 50 - ally.x) * 0.05;
        ally.y += (player.y - 50 - ally.y) * 0.05;
    });
}

function handlePlayerMovement() {
    if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
    if (keys['ArrowDown'] || keys['s']) player.y += player.speed;
    if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
    if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
}

// Weapons & Skills
function fireProjectile(shooter = player) {
    if (gamePaused) return;
    let closestEnemy = findClosestEnemy(shooter);
    if (!closestEnemy) return;

    let angle = Math.atan2(closestEnemy.y - shooter.y, closestEnemy.x - shooter.x);
    for (let i = 0; i < shooter.numProjectiles; i++) {
        let spread = (i - (shooter.numProjectiles - 1) / 2) * 0.2; // 0.2 radian spread
        projectiles.push({
            x: shooter.x,
            y: shooter.y,
            size: 5,
            speed: shooter.projectileSpeed,
            damage: shooter.projectileDamage,
            dx: Math.cos(angle + spread),
            dy: Math.sin(angle + spread)
        });
    }
}

function drawBarrier() {
    ctx.strokeStyle = '#1abc9c';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.barrier.size, player.barrier.rotation, player.barrier.rotation + Math.PI * 1.5);
    ctx.stroke();
}

function updateProjectiles() {
    projectiles.forEach((p, i) => {
        p.x += p.dx * p.speed;
        p.y += p.dy * p.speed;
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
            projectiles.splice(i, 1);
        }
    });
}

function drawProjectile(p) {
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
}

// Enemies
function spawnEnemy() {
    if (gamePaused) return;
    let x, y;
    if (Math.random() < 0.5) {
        x = Math.random() < 0.5 ? 0 - 20 : canvas.width + 20;
        y = Math.random() * canvas.height;
    } else {
        x = Math.random() * canvas.width;
        y = Math.random() < 0.5 ? 0 - 20 : canvas.height + 20;
    }
    enemies.push({ x, y, size: 15, speed: 1.5, health: 30 + player.level * 5 });
}

function updateEnemies() {
    enemies.forEach(e => {
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(angle) * e.speed;
        e.y += Math.sin(angle) * e.speed;
    });
}

function drawEnemy(e) {
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
}

function findClosestEnemy(from) {
    let closest = null;
    let minDistance = Infinity;
    enemies.forEach(e => {
        let dist = Math.hypot(from.x - e.x, from.y - e.y);
        if (dist < minDistance) {
            minDistance = dist;
            closest = e;
        }
    });
    return closest;
}

// XP Gems
function dropXpGem(x, y) {
    xpGems.push({ x, y, size: 7, value: 20 });
}

function drawXpGem(gem) {
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.arc(gem.x, gem.y, gem.size, 0, Math.PI * 2);
    ctx.fill();
}

// Collisions
function handleCollisions() {
    // Projectile-Enemy
    projectiles.forEach((p, pi) => {
        enemies.forEach((e, ei) => {
            if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.size / 2) {
                e.health -= p.damage;
                if(p.x) projectiles.splice(pi, 1);
                if (e.health <= 0) {
                    if(e.x) enemies.splice(ei, 1);
                    dropXpGem(e.x, e.y);
                }
            }
        });
    });

    // Player-Enemy
    enemies.forEach((e, ei) => {
        if (Math.hypot(player.x - e.x, player.y - e.y) < player.size / 2 + e.size / 2) {
            player.health -= 10;
            if(e.x) enemies.splice(ei, 1);
            if (player.health <= 0) gameOver();
        }
    });

    // Barrier-Enemy
    if (player.barrier.active) {
        enemies.forEach((e, ei) => {
            if (Math.hypot(player.x - e.x, player.y - e.y) < player.barrier.size + e.size / 2) {
                e.health -= player.barrier.damage;
                if (e.health <= 0) {
                    if(e.x) enemies.splice(ei, 1);
                    dropXpGem(e.x, e.y);
                }
            }
        });
    }

    // Player-XP Gem
    xpGems.forEach((gem, i) => {
        if (Math.hypot(player.x - gem.x, player.y - gem.y) < player.size / 2 + 50) { // Increased pickup range
            if(gem.x) xpGems.splice(i, 1);
            gainXp(gem.value);
        }
    });
}

// UI & Leveling
function drawUI() {
    ctx.fillStyle = 'white';
    ctx.font = '16px Malgun Gothic';
    ctx.fillText(`레벨: ${player.level}`, 10, 80);
    // Health bar
    ctx.fillStyle = 'grey';
    ctx.fillRect(10, 10, 200, 20);
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(10, 10, (player.health / player.maxHealth) * 200, 20);
    // XP bar
    ctx.fillStyle = 'grey';
    ctx.fillRect(10, 40, 200, 20);
    ctx.fillStyle = '#3498db';
    ctx.fillRect(10, 40, (player.xp / player.xpToNextLevel) * 200, 20);
}

function gainXp(amount) {
    player.xp += amount;
    if (player.xp >= player.xpToNextLevel) {
        levelUp();
    }
}

function levelUp() {
    gamePaused = true;
    player.level++;
    player.xp -= player.xpToNextLevel;
    player.xpToNextLevel *= 1.5;
    player.health = player.maxHealth; // Heal on level up
    showUpgradeOptions();
}

const allUpgrades = [
    { name: '헬스왕 강소명', description: '주변에 베리어가 생겨 적에게 피해를 줍니다.', apply: () => { player.barrier.active = true; if(!barrierInterval) barrierInterval = setInterval(() => { if(player.barrier.active) enemies.forEach(e => { if (Math.hypot(player.x - e.x, player.y - e.y) < player.barrier.size + e.size / 2) e.health -= player.barrier.damage; }); }, 200); } },
    { name: '진우석: 세금 맛있군요 더 줘', description: '총알이 샷건처럼 2발로 늘어납니다.', apply: () => player.numProjectiles = 2 },
    { name: '심승보: 아 인생 쉽노 ㅋ', description: '동료가 생겨 함께 공격합니다.', apply: () => {
        const newAlly = { x: player.x - 50, y: player.y - 50, size: 15, numProjectiles: 1, projectileSpeed: 5, projectileDamage: 8, attackSpeed: 1500 };
        allies.push(newAlly);
        setInterval(() => fireProjectile(newAlly), newAlly.attackSpeed);
    } },
    { name: '김홍섭: 돔황챠', description: '이동 속도가 증가합니다.', apply: () => player.speed += 1.5 },
    { name: '김승율: 나는 행복합니다', description: '축하합니다! 당신은 행복해졌습니다.', apply: () => gameOver() },
    { name: '공격력 강화', description: '모든 공격의 데미지가 증가합니다.', apply: () => { player.projectileDamage += 5; player.barrier.damage += 2; allies.forEach(a => a.projectileDamage += 3); } },
    { name: '공격 속도 강화', description: '기본 공격의 속도가 빨라집니다.', apply: () => { player.attackSpeed = Math.max(200, player.attackSpeed - 150); restartIntervals(); } },
    { name: '최대 체력 증가', description: '최대 체력과 현재 체력이 증가합니다.', apply: () => { player.maxHealth += 30; player.health += 30; } },
    { name: '흡혈', description: '이제부터 적을 처치하면 체력을 약간 회복합니다.', apply: () => { player.lifesteal = (player.lifesteal || 0) + 1; } },
];

function showUpgradeOptions() {
    upgradeOptionsContainer.innerHTML = '';
    let availableUpgrades = [...allUpgrades].sort(() => 0.5 - Math.random()).slice(0, 3);
    
    availableUpgrades.forEach(upgrade => {
        const button = document.createElement('button');
        button.innerHTML = `${upgrade.name}<br><small style="color: #ccc;">${upgrade.description}</small>`;
        button.className = 'upgrade-option';
        button.onclick = () => selectUpgrade(upgrade);
        upgradeOptionsContainer.appendChild(button);
    });

    upgradeModal.style.display = 'block';
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    upgradeModal.style.display = 'none';
    gamePaused = false;
    requestAnimationFrame(gameLoop);
}

// Event Listeners
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// Intervals
let fireInterval, spawnInterval;
function restartIntervals() {
    clearInterval(fireInterval);
    fireInterval = setInterval(() => fireProjectile(player), player.attackSpeed);
}

spawnInterval = setInterval(spawnEnemy, 2000);
restartIntervals();

// --- 모바일 조이스틱 코드 추가 ---
const joystickContainer = document.getElementById('joystick-container');
const joystickStick = document.getElementById('joystick-stick');
let joystickActive = false;
let joystickStartX, joystickStartY, stickStartX, stickStartY;

function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

if (isMobile()) {
    joystickContainer.style.display = 'block';

    joystickContainer.addEventListener('touchstart', (e) => {
        joystickActive = true;
        const touch = e.changedTouches[0];
        joystickStartX = touch.clientX;
        joystickStartY = touch.clientY;
        stickStartX = joystickStick.offsetLeft;
        stickStartY = joystickStick.offsetTop;
    }, { passive: false });

    joystickContainer.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - joystickStartX;
        const deltaY = touch.clientY - joystickStartY;
        const distance = Math.hypot(deltaX, deltaY);
        const angle = Math.atan2(deltaY, deltaX);
        
        const maxDist = 30; // Base radius - stick radius
        const moveX = Math.min(maxDist, distance) * Math.cos(angle);
        const moveY = Math.min(maxDist, distance) * Math.sin(angle);

        joystickStick.style.left = `${stickStartX + moveX}px`;
        joystickStick.style.top = `${stickStartY + moveY}px`;

        // Update keys based on angle
        keys = {}; // Reset keys
        if (distance > 10) { // Dead zone
            if (angle > -2.35 && angle < -0.78) keys['ArrowUp'] = true;
            if (angle > 0.78 && angle < 2.35) keys['ArrowDown'] = true;
            if (angle > -0.78 && angle < 0.78) keys['ArrowRight'] = true;
            if (angle < -2.35 || angle > 2.35) keys['ArrowLeft'] = true;
        }

    }, { passive: false });

    window.addEventListener('touchend', (e) => {
        if (!joystickActive) return;
        joystickActive = false;
        joystickStick.style.left = `30px`;
        joystickStick.style.top = `30px`;
        keys = {}; // Reset all keys
    });
}

// Start Game
gameLoop();

</script>
</body>
</html>
